From cd4183bbf00f3883d07c962e9b4ae7bdea1c9904 Mon Sep 17 00:00:00 2001
From: Franklin S Cooper Jr <fcooper@ti.com>
Date: Tue, 11 Aug 2015 14:39:36 -0500
Subject: [PATCH] Hack patch

---
 __init__.py  |  20 +-
 __init__.pyc | Bin 2077 -> 0 bytes
 client.py    | 231 +++++++++--------
 client.pyc   | Bin 28879 -> 0 bytes
 client.py~   | 795 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 errors.py    |  13 -
 errors.pyc   | Bin 4225 -> 0 bytes
 ex.pyc       | Bin 3648 -> 0 bytes
 image.pyc    | Bin 3483 -> 0 bytes
 listing.py   |  66 ++---
 listing.pyc  | Bin 11748 -> 0 bytes
 page.py      | 160 +++++++-----
 page.pyc     | Bin 15392 -> 0 bytes
 sleep.pyc    | Bin 2650 -> 0 bytes
 util.py      |   6 +-
 util.pyc     | Bin 539 -> 0 bytes
 16 files changed, 1052 insertions(+), 239 deletions(-)
 delete mode 100644 __init__.pyc
 delete mode 100644 client.pyc
 create mode 100644 client.py~
 delete mode 100644 errors.pyc
 delete mode 100644 ex.pyc
 delete mode 100644 image.pyc
 delete mode 100644 listing.pyc
 delete mode 100644 page.pyc
 delete mode 100644 sleep.pyc
 delete mode 100644 util.pyc

diff --git a/__init__.py b/__init__.py
index b11b25d..bb32dde 100644
--- a/__init__.py
+++ b/__init__.py
@@ -23,20 +23,6 @@
  OTHER DEALINGS IN THE SOFTWARE.
 """
 
-from mwclient.errors import *
-from mwclient.client import Site, __ver__
-import logging
-import warnings
-
-# Show DeprecationWarning
-warnings.simplefilter('always', DeprecationWarning)
-
-# Logging: Add a null handler to avoid "No handler found" warnings.
-try:
-    from logging import NullHandler
-except ImportError:
-    class NullHandler(logging.Handler):
-        def emit(self, record):
-            pass
-
-logging.getLogger(__name__).addHandler(NullHandler())
+from errors import *
+from client import Site, __ver__
+import ex
diff --git a/__init__.pyc b/__init__.pyc
deleted file mode 100644
index 79d445eea7bc0b71a600f6c0e429fdace35c33df..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 2077
zcmcIl+iu%N5M5ff95YUD2#UTG82F)80!4CMpaF`YC@s+u5s4H?DvtFcP~=Klhav^;
zDu$lZ=YC1Qq`%V-XwNQ{8tHROh|9gq%sFR<95w!YWba0QOj5SLj_~{ixBMML#@H02
z#j*pITP)VI2FnlFy1}LmwmxLjLuTpSLzW-0>5;L;yve3b#+&T+m}N(dKVTmYn6-Os
zj+@$aeZr<E%(^a~vO{jOcQ&hjW0qxQ$BZAb+lOp{pbyxujD2A22Bw9@-s+Q6#vic{
z7Q6k7@e_TBxdr&Bb)s3nJY>wKUb)#-V!2Y(N}tfh`T38}F3z7nr^{-W6cm@ml18Ff
z**1-NwH8u}vLGR8#VbDF(XvVk#j`doD$c1~P`XO0C2x}|DJgce;gu{4o65OLL?I9@
zp%jqXRILz4mJ4;4R2<eBB~q5DNDz>+GTp9up%Mi^n-(JHl3HrT=`7m2oINox8BcN&
z1;TOqctm$Xt;(&ksp3*qBGpmauuAi7rdjOIDHm%|V;Fyv38~3%C2!k?YMa(&CKfw9
zxskTn&T}DGZOVj>J>M$mm3lMf1>CfhZdsA!d2T`oP&az-2^u4fg9L%WK2HYuZdI-|
z8T(!h^0e4i1wfG*IAtaBW-xDgs`QQ)zbNy(yn{LoT4X|NmOr6#F%FY?`JNj+b+wC9
zfv(BAse|EBS9gCTS4p1J96ai@0UBA>dnllh1c}?ZRCogfO0X#_gZOW$9nE0iQWRXp
z*G}k?7tuHj-gtetPiIbq^;w&)y?78zVuD5J`0)(|SLFCN^xE_LD1`fV9J*0NK}g<c
zJoMatn>@caob)~a6<xy74`Ld6BQHkOI53F&Se_f%I^4(&djrIFF1?`_-?Zt<i+vsR
z3Q-*zJ7MhgCPOEr@gy7vkqZKS8-ab#zY2llj$A+P02h1YzQKZ`fioN$FlPb*p<&ny
z#y6q&Y7pBr2!?$ZyO%D=IhRAX27|EP(D6oX>N_Lnm22DrWGOUeH9woK2d>!zqJv*A
z_5xok=>>iqV%dh$FxE*izSmylw#f;-2xM)#3IhP>q{2lf&ex8<TZhpJ|FkYJ(RG?Y
zcn~6E2D<M$LqtQB{7<Yqw)hKI%R(zrdU)D8&{H%O774}GF($LwdtS|EzG`BT<afzV
z)(#J`_P2RHz^9V)D%4*8^i>`061V&k14my)e`C78O%GTYnE<KA(zmwl;g&iAtm<RG
zg%!IegfDSnI8;0>tE@iNCh|3gE<QNkP0lY~{D97vmuZrBJM|+M^X_JcR#IGaUUVgN
zJ=-MdyJX2_cYT-U0v)P5o1wF**{lOgO@rfu{$2;y1ew)pU{nt<%w|Qh=Chfy%>r#@
zn`0U3RNZqjv;Ufy$?$i;F{GMS>vPQaHA1TeC%y4eQioSnS;<fLYPF%xc&L>b@4Q?t
z(Q%ACv~k_xr8>o_6zfgS(Y6(@)K}Q(^9{0Z+WB>DXgDeTDtK$%JX{TGqV8V{rT?dv
zTnzz&mqe$~q%O&_y~Y2WH6!a~U8kSF0la*Sp?P3iUt6cvY2%AV!+LBzvc5h18`M!P
AfB*mh

diff --git a/client.py b/client.py
index 1c19335..84d5c0c 100644
--- a/client.py
+++ b/client.py
@@ -5,7 +5,6 @@ import sys
 import weakref
 import logging
 from six import text_type
-import six
 
 try:
     # Python 2.7+
@@ -14,27 +13,40 @@ except ImportError:
     # Python 2.6
     from ordereddict import OrderedDict
 
-try:
-    import json
-except ImportError:
-    import simplejson as json
+
+import simplejson as json
 import requests
 from requests.auth import HTTPBasicAuth, AuthBase
 
-import mwclient.errors as errors
-import mwclient.listing as listing
-from mwclient.sleep import Sleepers
+import errors
+import listing
+import page
 
 try:
     import gzip
 except ImportError:
     gzip = None
 
-__ver__ = '0.8.0.dev1'
+__ver__ = '0.7.2.dev1'
 
 log = logging.getLogger(__name__)
 
 
+def parse_timestamp(t):
+    if t == '0000-00-00T00:00:00Z':
+        return (0, 0, 0, 0, 0, 0, 0, 0)
+    return time.strptime(t, '%Y-%m-%dT%H:%M:%SZ')
+
+
+class WaitToken(object):
+
+    def __init__(self):
+        self.id = '%x' % random.randint(0, sys.maxint)
+
+    def __hash__(self):
+        return hash(self.id)
+
+
 class Site(object):
     api_limit = 500
 
@@ -47,6 +59,9 @@ class Site(object):
         self.ext = ext
         self.credentials = None
         self.compress = compress
+        self.retry_timeout = retry_timeout
+        self.max_retries = max_retries
+        self.wait_callback = wait_callback
         self.max_lag = text_type(max_lag)
         self.force_login = force_login
 
@@ -57,7 +72,8 @@ class Site(object):
         else:
             raise RuntimeError('Authentication is not a tuple or an instance of AuthBase')
 
-        self.sleepers = Sleepers(max_retries, retry_timeout, wait_callback)
+        # The token string => token object mapping
+        self.wait_tokens = weakref.WeakKeyDictionary()
 
         # Site properties
         self.blocked = False    # Whether current user is blocked
@@ -103,11 +119,11 @@ class Site(object):
 
     def site_init(self):
         meta = self.api('query', meta='siteinfo|userinfo',
-                        siprop='general|namespaces', uiprop='groups|rights', retry_on_error=False)
+                        siprop='general|namespaces', uiprop='groups|rights')
 
         # Extract site info
         self.site = meta['query']['general']
-        self.namespaces = dict(((i['id'], i.get('*', '')) for i in six.itervalues(meta['query']['namespaces'])))
+        self.namespaces = dict(((i['id'], i.get('*', '')) for i in meta['query']['namespaces'].itervalues()))
         self.writeapi = 'writeapi' in self.site
 
         # Determine version
@@ -168,8 +184,8 @@ class Site(object):
         """
         kwargs.update(args)
 
-        if 'continue' not in kwargs:
-            kwargs['continue'] = ''
+        #if 'continue' not in kwargs:
+        #    kwargs['continue'] = ''
         if action == 'query':
             if 'meta' in kwargs:
                 kwargs['meta'] += '|userinfo'
@@ -180,18 +196,18 @@ class Site(object):
             else:
                 kwargs['uiprop'] = 'blockinfo|hasmsg'
 
-        sleeper = self.sleepers.make()
-
+        token = self.wait_token()
         while True:
             info = self.raw_api(action, **kwargs)
             if not info:
                 info = {}
-            if self.handle_api_result(info, sleeper=sleeper):
+            res = self.handle_api_result(info, token=token)
+            if res:
                 return info
 
-    def handle_api_result(self, info, kwargs=None, sleeper=None):
-        if sleeper is None:
-            sleeper = self.sleepers.make()
+    def handle_api_result(self, info, kwargs=None, token=None):
+        if token is None:
+            token = self.wait_token()
 
         try:
             userinfo = info['query']['userinfo']
@@ -201,11 +217,11 @@ class Site(object):
             self.blocked = (userinfo['blockedby'], userinfo.get('blockreason', u''))
         else:
             self.blocked = False
-        self.hasmsg = 'messages' in userinfo
+        self.hasmsg = 'message' in userinfo
         self.logged_in = 'anon' not in userinfo
         if 'error' in info:
             if info['error']['code'] in (u'internal_api_error_DBConnectionError', u'internal_api_error_DBQueryError'):
-                sleeper.sleep()
+                self.wait(token)
                 return False
             if '*' in info['error']:
                 raise errors.APIError(info['error']['code'],
@@ -217,36 +233,16 @@ class Site(object):
     @staticmethod
     def _query_string(*args, **kwargs):
         kwargs.update(args)
-        qs1 = [(k, v) for k, v in six.iteritems(kwargs) if k not in ('wpEditToken', 'token')]
-        qs2 = [(k, v) for k, v in six.iteritems(kwargs) if k in ('wpEditToken', 'token')]
+        qs1 = [(k, v) for k, v in kwargs.iteritems() if k not in ('wpEditToken', 'token')]
+        qs2 = [(k, v) for k, v in kwargs.iteritems() if k in ('wpEditToken', 'token')]
         return OrderedDict(qs1 + qs2)
 
-    def raw_call(self, script, data, files=None, retry_on_error=True):
-        """
-        Perform a generic API call and return the raw text.
-
-        In the event of a network problem, or a HTTP response with status code 5XX,
-        we'll wait and retry the configured number of times before giving up
-        if `retry_on_error` is True.
-
-        `requests.exceptions.HTTPError` is still raised directly for
-        HTTP responses with status codes in the 4XX range, and invalid
-        HTTP responses.
-
-        Args:
-            script (str): Script name, usually 'api'.
-            data (dict): Post data
-            files (dict): Files to upload
-            retry_on_error (bool): Retry on connection error
-
-        Returns:
-            The raw text response.
-        """
+    def raw_call(self, script, data, files=None):
         url = self.path + script + self.ext
         headers = {}
         if self.compress and gzip:
             headers['Accept-Encoding'] = 'gzip'
-        sleeper = self.sleepers.make((script, data))
+        token = self.wait_token((script, data))
         while True:
             scheme = 'http'  # Should we move to 'https' as default?
             host = self.host
@@ -259,43 +255,56 @@ class Site(object):
                 stream = self.connection.post(fullurl, data=data, files=files, headers=headers)
                 if stream.headers.get('x-database-lag'):
                     wait_time = int(stream.headers.get('retry-after'))
-                    log.warning('Database lag exceeds max lag. Waiting for %d seconds', wait_time)
-                    sleeper.sleep(wait_time)
+                    log.warn('Database lag exceeds max lag. Waiting for %d seconds', wait_time)
+                    self.wait(token, wait_time)
                 elif stream.status_code == 200:
                     return stream.text
                 elif stream.status_code < 500 or stream.status_code > 599:
                     stream.raise_for_status()
                 else:
-                    if not retry_on_error:
-                        stream.raise_for_status()
-                    log.warning('Received %s response: %s. Retrying in a moment.', stream.status_code, stream.text)
-                    sleeper.sleep()
+                    log.warn('Received %s response: %s. Retrying in a moment.', stream.status_code, stream.text)
+                    self.wait(token)
 
             except requests.exceptions.ConnectionError:
                 # In the event of a network problem (e.g. DNS failure, refused connection, etc),
                 # Requests will raise a ConnectionError exception.
-                if not retry_on_error:
-                    raise
-                log.warning('Connection error. Retrying in a moment.')
-                sleeper.sleep()
+                log.warn('Connection error. Retrying in a moment.')
+                self.wait(token)
+
+            except requests.exceptions.HTTPError as e:
+                log.warn('HTTP error: %s', e.message)
+                raise
+
+            except requests.exceptions.TooManyRedirects:
+                raise
 
     def raw_api(self, action, *args, **kwargs):
         """Sends a call to the API."""
-        try:
-            retry_on_error = kwargs.pop('retry_on_error')
-        except KeyError:
-            retry_on_error = True
         kwargs['action'] = action
         kwargs['format'] = 'json'
+	#kwargs['utf8'] = True
         data = self._query_string(*args, **kwargs)
-        res = self.raw_call('api', data, retry_on_error=retry_on_error)
+
+        res = self.raw_call('api', data)
+
+	first = res.find("legaltitlechars")
+	if first is not -1:
+		second = res.find(',"case":"first-letter"',first)
+
+		res = res[:first-2] + res[second:]
+		res = "{\""+res[3:]
+
+	if res.startswith(u'\ufeff'):
+		res = res[1:]
 
         try:
-            return json.loads(res)
+            	return json.loads(res)		
         except ValueError:
             if res.startswith('MediaWiki API is not enabled for this site.'):
                 raise errors.APIDisabledError
-            raise errors.InvalidResponse(res)
+
+            print repr(res)		
+            raise ValueError('Could not decode JSON: %s' % res)
 
     def raw_index(self, action, *args, **kwargs):
         """Sends a call to index.php rather than the API."""
@@ -304,6 +313,25 @@ class Site(object):
         data = self._query_string(*args, **kwargs)
         return self.raw_call('index', data)
 
+    def wait_token(self, args=None):
+        token = WaitToken()
+        self.wait_tokens[token] = (0, args)
+        return token
+
+    def wait(self, token, min_wait=0):
+        retry, args = self.wait_tokens[token]
+        self.wait_tokens[token] = (retry + 1, args)
+        if retry > self.max_retries and self.max_retries != -1:
+            raise errors.MaximumRetriesExceeded(self, token, args)
+        self.wait_callback(self, token, retry, args)
+
+        timeout = self.retry_timeout * retry
+        if timeout < min_wait:
+            timeout = min_wait
+        log.debug('Sleeping for %d seconds', timeout)
+        time.sleep(timeout)
+        return self.wait_tokens[token]
+
     def require(self, major, minor, revision=None, raise_error=True):
         if self.version is None:
             if raise_error is None:
@@ -363,10 +391,12 @@ class Site(object):
         if username and password:
             self.credentials = (username, password, domain)
         if cookies:
-            self.connection.cookies.update(cookies)
+            if self.host not in self.conn.cookies:
+                self.conn.cookies[self.host] = http.CookieJar()
+            self.conn.cookies[self.host].update(cookies)
 
         if self.credentials:
-            sleeper = self.sleepers.make()
+            wait_token = self.wait_token()
             kwargs = {
                 'lgname': self.credentials[0],
                 'lgpassword': self.credentials[1]
@@ -380,7 +410,7 @@ class Site(object):
                 elif login['login']['result'] == 'NeedToken':
                     kwargs['lgtoken'] = login['login']['token']
                 elif login['login']['result'] == 'Throttled':
-                    sleeper.sleep(int(login['login'].get('wait', 5)))
+                    self.wait(wait_token, login['login'].get('wait', 5))
                 else:
                     raise errors.LoginError(self, login['login'])
 
@@ -417,7 +447,7 @@ class Site(object):
                     title = 'Test'
                 info = self.api('query', titles=title,
                                 prop='info', intoken=type)
-                for i in six.itervalues(info['query']['pages']):
+                for i in info['query']['pages'].itervalues():
                     if i['title'] == title:
                         self.tokens[type] = i['%stoken' % type]
 
@@ -508,14 +538,36 @@ class Site(object):
 
             files = {'file': file}
 
-        sleeper = self.sleepers.make()
+        wait_token = self.wait_token()
         while True:
-            data = self.raw_call('api', postdata, files)
-            info = json.loads(data)
-            if not info:
-                info = {}
-            if self.handle_api_result(info, kwargs=predata, sleeper=sleeper):
-                return info.get('upload', {})
+            try:
+                data = self.raw_call('api', postdata, files)
+
+
+		# Remove html entity since it causes JSON errors
+		first = data.find('"html":')
+		second = data.find('"canonicaltitle":')
+
+		
+		data = data[:first] + data[second:]
+
+		# Remove ufeff since it causes JSON errors
+		if data.startswith(u'\ufeff'):
+			data = data[1:]
+                info = json.loads(data)
+                if not info:
+                    info = {}
+                if self.handle_api_result(info, kwargs=predata):
+                    return info.get('upload', {})
+            except requests.exceptions.HTTPError as e:
+                if e.args[0] == 503 and e.args[1].getheader('X-Database-Lag'):
+                    self.wait(wait_token, int(e.args[1].getheader('Retry-After')))
+                elif e.args[0] < 500 or e.args[0] > 599:
+                    raise
+                else:
+                    self.wait(wait_token)
+            except requests.exceptions.ConnectionError:
+                self.wait(wait_token)
 
     def parse(self, text=None, title=None, page=None):
         kwargs = {}
@@ -584,6 +636,7 @@ class Site(object):
                                                    rights=rights,
                                                    witheditsonly=witheditsonly,
                                                    activeusers=activeusers))
+        print kwargs
         return listing.List(self, 'allusers', 'au', limit=limit, **kwargs)
 
     def blocks(self, start=None, end=None, dir='older', ids=None, users=None, limit=None,
@@ -645,12 +698,6 @@ class Site(object):
                                                    end=end, dir=dir, user=user, title=title, action=action))
         return listing.List(self, 'logevents', 'le', limit=limit, **kwargs)
 
-    def checkuserlog(self, user=None, target=None, limit=10, dir='older', start=None, end=None):
-
-        kwargs = dict(listing.List.generate_kwargs('cul', target=target, start=start,
-                                                   end=end, dir=dir, user=user))
-        return listing.NestedList('entries', self, 'checkuserlog', 'cul', limit=limit, **kwargs)
-
     # def protectedtitles requires 1.15
     def random(self, namespace, limit=20):
         """Retrieves a generator of random page from a particular namespace.
@@ -673,28 +720,7 @@ class Site(object):
                                                    toponly='1' if toponly else None))
         return listing.List(self, 'recentchanges', 'rc', limit=limit, **kwargs)
 
-    def search(self, search, namespace='0', what=None, redirects=False, limit=None):
-        """
-        Perform a full text search.
-        API doc: https://www.mediawiki.org/wiki/API:Search
-
-            >>> for result in site.search('prefix:Template:Citation/'):
-            ...     print(result.get('title'))
-
-        Args:
-            search (str): The query string
-            namespace (int): The namespace to search (default: 0)
-            what (str): Search scope: 'text' for fulltext, or 'title' for titles only.
-                        Depending on the search backend, both options may not be available.
-                        For instance
-                        `CirrusSearch <https://www.mediawiki.org/wiki/Help:CirrusSearch>`_
-                        doesn't support 'title', but instead provides an "intitle:"
-                        query string filter.
-            redirects (bool): Include redirect pages in the search (option removed in MediaWiki 1.23).
-
-        Returns:
-            mwclient.listings.List: Search results iterator
-        """
+    def search(self, search, namespace='0', what='title', redirects=False, limit=None):
 
         kwargs = dict(listing.List.generate_kwargs('sr', search=search, namespace=namespace, what=what))
         if redirects:
@@ -744,3 +770,4 @@ class Site(object):
             kwargs['title'] = title
         result = self.raw_api('ask', query=query, **kwargs)
         return result['query']['results']
+
diff --git a/client.pyc b/client.pyc
deleted file mode 100644
index 1bfab7175fd293a2ba545a689d7adeffe20ce243..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 28879
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
O>X^uD$nmX=5Bz_lcyjju

diff --git a/client.py~ b/client.py~
new file mode 100644
index 0000000..a70063b
--- /dev/null
+++ b/client.py~
@@ -0,0 +1,795 @@
+import warnings
+import time
+import random
+import sys
+import weakref
+import logging
+from six import text_type
+
+try:
+    # Python 2.7+
+    from collections import OrderedDict
+except ImportError:
+    # Python 2.6
+    from ordereddict import OrderedDict
+
+
+import simplejson as json
+import requests
+from requests.auth import HTTPBasicAuth, AuthBase
+
+import errors
+import listing
+import page
+
+try:
+    import gzip
+except ImportError:
+    gzip = None
+
+__ver__ = '0.7.2.dev1'
+
+log = logging.getLogger(__name__)
+
+
+def parse_timestamp(t):
+    if t == '0000-00-00T00:00:00Z':
+        return (0, 0, 0, 0, 0, 0, 0, 0)
+    return time.strptime(t, '%Y-%m-%dT%H:%M:%SZ')
+
+
+class WaitToken(object):
+
+    def __init__(self):
+        self.id = '%x' % random.randint(0, sys.maxint)
+
+    def __hash__(self):
+        return hash(self.id)
+
+
+class Site(object):
+    api_limit = 500
+
+    def __init__(self, host, path='/w/', ext='.php', pool=None, retry_timeout=30,
+                 max_retries=25, wait_callback=lambda *x: None, clients_useragent=None,
+                 max_lag=3, compress=True, force_login=True, do_init=True, httpauth=None):
+        # Setup member variables
+        self.host = host
+        self.path = path
+        self.ext = ext
+        self.credentials = None
+        self.compress = compress
+        self.retry_timeout = retry_timeout
+        self.max_retries = max_retries
+        self.wait_callback = wait_callback
+        self.max_lag = text_type(max_lag)
+        self.force_login = force_login
+
+        if isinstance(httpauth, (list, tuple)):
+            self.httpauth = HTTPBasicAuth(*httpauth)
+        elif httpauth is None or isinstance(httpauth, (AuthBase,)):
+            self.httpauth = httpauth
+        else:
+            raise RuntimeError('Authentication is not a tuple or an instance of AuthBase')
+
+        # The token string => token object mapping
+        self.wait_tokens = weakref.WeakKeyDictionary()
+
+        # Site properties
+        self.blocked = False    # Whether current user is blocked
+        self.hasmsg = False  # Whether current user has new messages
+        self.groups = []    # Groups current user belongs to
+        self.rights = []    # Rights current user has
+        self.tokens = {}    # Edit tokens of the current user
+        self.version = None
+
+        self.namespaces = self.default_namespaces
+        self.writeapi = False
+
+        # Setup connection
+        if pool is None:
+            self.connection = requests.Session()
+            self.connection.auth = self.httpauth
+            self.connection.headers['User-Agent'] = 'MwClient/' + __ver__ + ' (https://github.com/mwclient/mwclient)'
+            if clients_useragent:
+                self.connection.headers['User-Agent'] = clients_useragent + ' - ' + self.connection.headers['User-Agent']
+        else:
+            self.connection = pool
+
+        # Page generators
+        self.pages = listing.PageList(self)
+        self.categories = listing.PageList(self, namespace=14)
+        self.images = listing.PageList(self, namespace=6)
+
+        # Compat page generators
+        self.Pages = self.pages
+        self.Categories = self.categories
+        self.Images = self.images
+
+        # Initialization status
+        self.initialized = False
+
+        if do_init:
+            try:
+                self.site_init()
+            except errors.APIError as e:
+                # Private wiki, do init after login
+                if e.args[0] not in (u'unknown_action', u'readapidenied'):
+                    raise
+
+    def site_init(self):
+        meta = self.api('query', meta='siteinfo|userinfo',
+                        siprop='general|namespaces', uiprop='groups|rights')
+
+        # Extract site info
+        self.site = meta['query']['general']
+        self.namespaces = dict(((i['id'], i.get('*', '')) for i in meta['query']['namespaces'].itervalues()))
+        self.writeapi = 'writeapi' in self.site
+
+        # Determine version
+        if self.site['generator'].startswith('MediaWiki '):
+            version = self.site['generator'][10:].split('.')
+
+            def split_num(s):
+                i = 0
+                while i < len(s):
+                    if s[i] < '0' or s[i] > '9':
+                        break
+                    i += 1
+                if s[i:]:
+                    return (int(s[:i]), s[i:], )
+                else:
+                    return (int(s[:i]), )
+            self.version = sum((split_num(s) for s in version), ())
+
+            if len(self.version) < 2:
+                raise errors.MediaWikiVersionError('Unknown MediaWiki %s' % '.'.join(version))
+        else:
+            raise errors.MediaWikiVersionError('Unknown generator %s' % self.site['generator'])
+
+        # Require MediaWiki version >= 1.16
+        self.require(1, 16)
+
+        # User info
+        userinfo = meta['query']['userinfo']
+        self.username = userinfo['name']
+        self.groups = userinfo.get('groups', [])
+        self.rights = userinfo.get('rights', [])
+        self.initialized = True
+
+    default_namespaces = {0: u'', 1: u'Talk', 2: u'User', 3: u'User talk', 4: u'Project', 5: u'Project talk',
+                          6: u'Image', 7: u'Image talk', 8: u'MediaWiki', 9: u'MediaWiki talk', 10: u'Template', 11: u'Template talk',
+                          12: u'Help', 13: u'Help talk', 14: u'Category', 15: u'Category talk', -1: u'Special', -2: u'Media'}
+
+    def __repr__(self):
+        return "<Site object '%s%s'>" % (self.host, self.path)
+
+    def api(self, action, *args, **kwargs):
+        """
+        Perform a generic API call and handle errors. All arguments will be passed on.
+
+        Example:
+            To get coordinates from the GeoData MediaWiki extension at English Wikipedia:
+
+            >>> site = Site('en.wikipedia.org')
+            >>> result = site.api('query', prop='coordinates', titles='Oslo|Copenhagen')
+            >>> for page in result['query']['pages'].values():
+            ...     if 'coordinates' in page:
+            ...         print page['title'], page['coordinates'][0]['lat'], page['coordinates'][0]['lon']
+            Oslo 59.95 10.75
+            Copenhagen 55.6761 12.5683
+
+        Returns:
+            The raw response from the API call, as a dictionary.
+        """
+        kwargs.update(args)
+
+        #if 'continue' not in kwargs:
+        #    kwargs['continue'] = ''
+        if action == 'query':
+            if 'meta' in kwargs:
+                kwargs['meta'] += '|userinfo'
+            else:
+                kwargs['meta'] = 'userinfo'
+            if 'uiprop' in kwargs:
+                kwargs['uiprop'] += '|blockinfo|hasmsg'
+            else:
+                kwargs['uiprop'] = 'blockinfo|hasmsg'
+
+        token = self.wait_token()
+        while True:
+            info = self.raw_api(action, **kwargs)
+            if not info:
+                info = {}
+            res = self.handle_api_result(info, token=token)
+            if res:
+                return info
+
+    def handle_api_result(self, info, kwargs=None, token=None):
+        if token is None:
+            token = self.wait_token()
+
+        try:
+            userinfo = info['query']['userinfo']
+        except KeyError:
+            userinfo = ()
+        if 'blockedby' in userinfo:
+            self.blocked = (userinfo['blockedby'], userinfo.get('blockreason', u''))
+        else:
+            self.blocked = False
+        self.hasmsg = 'message' in userinfo
+        self.logged_in = 'anon' not in userinfo
+        if 'error' in info:
+            if info['error']['code'] in (u'internal_api_error_DBConnectionError', u'internal_api_error_DBQueryError'):
+                self.wait(token)
+                return False
+            if '*' in info['error']:
+                raise errors.APIError(info['error']['code'],
+                                      info['error']['info'], info['error']['*'])
+            raise errors.APIError(info['error']['code'],
+                                  info['error']['info'], kwargs)
+        return True
+
+    @staticmethod
+    def _query_string(*args, **kwargs):
+        kwargs.update(args)
+        qs1 = [(k, v) for k, v in kwargs.iteritems() if k not in ('wpEditToken', 'token')]
+        qs2 = [(k, v) for k, v in kwargs.iteritems() if k in ('wpEditToken', 'token')]
+        return OrderedDict(qs1 + qs2)
+
+    def raw_call(self, script, data, files=None):
+        url = self.path + script + self.ext
+        headers = {}
+        if self.compress and gzip:
+            headers['Accept-Encoding'] = 'gzip'
+        token = self.wait_token((script, data))
+        while True:
+            scheme = 'http'  # Should we move to 'https' as default?
+            host = self.host
+            if isinstance(host, (list, tuple)):
+                scheme, host = host
+
+            fullurl = '{scheme}://{host}{url}'.format(scheme=scheme, host=host, url=url)
+
+            try:
+                stream = self.connection.post(fullurl, data=data, files=files, headers=headers)
+                if stream.headers.get('x-database-lag'):
+                    wait_time = int(stream.headers.get('retry-after'))
+                    log.warn('Database lag exceeds max lag. Waiting for %d seconds', wait_time)
+                    self.wait(token, wait_time)
+                elif stream.status_code == 200:
+                    return stream.text
+                elif stream.status_code < 500 or stream.status_code > 599:
+                    stream.raise_for_status()
+                else:
+                    log.warn('Received %s response: %s. Retrying in a moment.', stream.status_code, stream.text)
+                    self.wait(token)
+
+            except requests.exceptions.ConnectionError:
+                # In the event of a network problem (e.g. DNS failure, refused connection, etc),
+                # Requests will raise a ConnectionError exception.
+                log.warn('Connection error. Retrying in a moment.')
+                self.wait(token)
+
+            except requests.exceptions.HTTPError as e:
+                log.warn('HTTP error: %s', e.message)
+                raise
+
+            except requests.exceptions.TooManyRedirects:
+                raise
+
+    def raw_api(self, action, *args, **kwargs):
+        """Sends a call to the API."""
+        kwargs['action'] = action
+        kwargs['format'] = 'json'
+	#kwargs['utf8'] = True
+        data = self._query_string(*args, **kwargs)
+
+        res = self.raw_call('api', data)
+
+	encoding = False
+	if res.startswith(u'\ufeff'):  # bytes \xef\xbb\xbf in utf-8 encoding
+    		encoding = True
+	#orig=res
+	first = res.find("legaltitlechars")
+	if first is not -1:
+		second = res.find(',"case":"first-letter"',first)
+
+		res = res[:first-2] + res[second:]
+		res = "{\""+res[3:]
+
+	#first = res.find('warnings')
+	#print "----------"
+	#print repr(res)
+	#if first != -1:
+	#	second = res.find('},',first)
+	#	res = res[:first-2] + res[second:]
+	#	res = "{"+res[3:]
+
+	
+	if res.startswith(u'\ufeff'):
+		#print "donkey"
+		res = res[1:]
+
+	#print "!!!!!!!!!!!!!!!!!!!!!!!!!"
+
+	#print repr(res.decode('utf-8-sig'))
+
+        try:
+            if encoding == True:
+            	return json.loads(res)
+            else:
+
+            	return json.loads(res)		
+        except ValueError:
+            if res.startswith('MediaWiki API is not enabled for this site.'):
+                raise errors.APIDisabledError
+
+            print repr(res)		
+            raise ValueError('Could not decode JSON: %s' % res)
+
+    def raw_index(self, action, *args, **kwargs):
+        """Sends a call to index.php rather than the API."""
+        kwargs['action'] = action
+        kwargs['maxlag'] = self.max_lag
+        data = self._query_string(*args, **kwargs)
+        return self.raw_call('index', data)
+
+    def wait_token(self, args=None):
+        token = WaitToken()
+        self.wait_tokens[token] = (0, args)
+        return token
+
+    def wait(self, token, min_wait=0):
+        retry, args = self.wait_tokens[token]
+        self.wait_tokens[token] = (retry + 1, args)
+        if retry > self.max_retries and self.max_retries != -1:
+            raise errors.MaximumRetriesExceeded(self, token, args)
+        self.wait_callback(self, token, retry, args)
+
+        timeout = self.retry_timeout * retry
+        if timeout < min_wait:
+            timeout = min_wait
+        log.debug('Sleeping for %d seconds', timeout)
+        time.sleep(timeout)
+        return self.wait_tokens[token]
+
+    def require(self, major, minor, revision=None, raise_error=True):
+        if self.version is None:
+            if raise_error is None:
+                return
+            raise RuntimeError('Site %s has not yet been initialized' % repr(self))
+
+        if revision is None:
+            if self.version[:2] >= (major, minor):
+                return True
+            elif raise_error:
+                raise errors.MediaWikiVersionError('Requires version %s.%s, current version is %s.%s'
+                                                   % ((major, minor) + self.version[:2]))
+            else:
+                return False
+        else:
+            raise NotImplementedError
+
+    # Actions
+    def email(self, user, text, subject, cc=False):
+        """
+        Send email to a specified user on the wiki.
+
+            >>> try:
+            ...     site.email('SomeUser', 'Some message', 'Some subject')
+            ... except mwclient.errors.NoSpecifiedEmailError as e:
+            ...     print 'The user does not accept email, or has not specified an email address.'
+
+        Args:
+            user (str): User name of the recipient
+            text (str): Body of the email
+            subject (str): Subject of the email
+            cc (bool): True to send a copy of the email to yourself (default is False)
+
+        Returns:
+            Dictionary of the JSON response
+
+        Raises:
+            NoSpecifiedEmailError (mwclient.errors.NoSpecifiedEmailError): if recipient does not accept email
+            EmailError (mwclient.errors.EmailError): on other errors
+        """
+
+        token = self.get_token('email')
+
+        try:
+            info = self.api('emailuser', target=user, subject=subject,
+                            text=text, ccme=cc, token=token)
+        except errors.APIError as e:
+            if e.args[0] == u'noemail':
+                raise errors.NoSpecifiedEmail(user, e.args[1])
+            raise errors.EmailError(*e)
+
+        return info
+
+    def login(self, username=None, password=None, cookies=None, domain=None):
+        """Login to the wiki."""
+
+        if username and password:
+            self.credentials = (username, password, domain)
+        if cookies:
+            if self.host not in self.conn.cookies:
+                self.conn.cookies[self.host] = http.CookieJar()
+            self.conn.cookies[self.host].update(cookies)
+
+        if self.credentials:
+            wait_token = self.wait_token()
+            kwargs = {
+                'lgname': self.credentials[0],
+                'lgpassword': self.credentials[1]
+            }
+            if self.credentials[2]:
+                kwargs['lgdomain'] = self.credentials[2]
+            while True:
+                login = self.api('login', **kwargs)
+                if login['login']['result'] == 'Success':
+                    break
+                elif login['login']['result'] == 'NeedToken':
+                    kwargs['lgtoken'] = login['login']['token']
+                elif login['login']['result'] == 'Throttled':
+                    self.wait(wait_token, login['login'].get('wait', 5))
+                else:
+                    raise errors.LoginError(self, login['login'])
+
+        if self.initialized:
+            info = self.api('query', meta='userinfo', uiprop='groups|rights')
+            userinfo = info['query']['userinfo']
+            self.username = userinfo['name']
+            self.groups = userinfo.get('groups', [])
+            self.rights = userinfo.get('rights', [])
+            self.tokens = {}
+        else:
+            self.site_init()
+
+    def get_token(self, type, force=False, title=None):
+
+        if self.version[:2] >= (1, 24):
+            # The 'csrf' (cross-site request forgery) token introduced in 1.24 replaces
+            # the majority of older tokens, like edittoken and movetoken.
+            if type not in ['watch', 'patrol', 'rollback', 'userrights']:
+                type = 'csrf'
+
+        if type not in self.tokens:
+            self.tokens[type] = '0'
+
+        if self.tokens.get(type, '0') == '0' or force:
+
+            if self.version[:2] >= (1, 24):
+                info = self.api('query', meta='tokens', type=type)
+                self.tokens[type] = info['query']['tokens']['%stoken' % type]
+
+            else:
+                if title is None:
+                    # Some dummy title was needed to get a token prior to 1.24
+                    title = 'Test'
+                info = self.api('query', titles=title,
+                                prop='info', intoken=type)
+                for i in info['query']['pages'].itervalues():
+                    if i['title'] == title:
+                        self.tokens[type] = i['%stoken' % type]
+
+        return self.tokens[type]
+
+    def upload(self, file=None, filename=None, description='', ignore=False, file_size=None,
+               url=None, filekey=None, comment=None):
+        """
+        Uploads a file to the site. Returns JSON result from the API.
+        Can raise `errors.InsufficientPermission` and `requests.exceptions.HTTPError`.
+
+        : Parameters :
+          - file         : File object or stream to upload.
+          - filename     : Destination filename, don't include namespace
+                           prefix like 'File:'
+          - description  : Wikitext for the file description page.
+          - ignore       : True to upload despite any warnings.
+          - file_size    : Deprecated in mwclient 0.7
+          - url          : URL to fetch the file from.
+          - filekey      : Key that identifies a previous upload that was
+                           stashed temporarily.
+          - comment      : Upload comment. Also used as the initial page text
+                           for new files if `description` is not specified.
+
+        Note that one of `file`, `filekey` and `url` must be specified, but not more
+        than one. For normal uploads, you specify `file`.
+
+        Example:
+
+        >>> client.upload(open('somefile', 'rb'), filename='somefile.jpg',
+                          description='Some description')
+        """
+
+        if file_size is not None:
+            # Note that DeprecationWarning is hidden by default since Python 2.7
+            warnings.warn(
+                'file_size is deprecated since mwclient 0.7',
+                DeprecationWarning
+            )
+            file_size = None
+
+        if filename is None:
+            raise TypeError('filename must be specified')
+
+        if len([x for x in [file, filekey, url] if x is not None]) != 1:
+            raise TypeError("exactly one of 'file', 'filekey' and 'url' must be specified")
+
+        image = self.Images[filename]
+        if not image.can('upload'):
+            raise errors.InsufficientPermission(filename)
+
+        predata = {}
+
+        if comment is None:
+            predata['comment'] = description
+        else:
+            predata['comment'] = comment
+            predata['text'] = description
+
+        if ignore:
+            predata['ignorewarnings'] = 'true'
+        predata['token'] = image.get_token('edit')
+        predata['action'] = 'upload'
+        predata['format'] = 'json'
+        predata['filename'] = filename
+        if url:
+            predata['url'] = url
+
+        # Renamed from sessionkey to filekey
+        # https://git.wikimedia.org/commit/mediawiki%2Fcore.git/5f13517e
+        if self.version[:2] < (1, 18):
+            predata['sessionkey'] = filekey
+        else:
+            predata['filekey'] = filekey
+
+        postdata = predata
+        files = None
+        if file is not None:
+
+            # Workaround for https://github.com/mwclient/mwclient/issues/65
+            # ----------------------------------------------------------------
+            # Since the filename in Content-Disposition is not interpreted,
+            # we can send some ascii-only dummy name rather than the real
+            # filename, which might contain non-ascii.
+            file = ('fake-filename', file)
+            # End of workaround
+            # ----------------------------------------------------------------
+
+            files = {'file': file}
+
+        wait_token = self.wait_token()
+        while True:
+            try:
+                data = self.raw_call('api', postdata, files)
+
+
+		# Remove html entity since it causes JSON errors
+		first = data.find('"html":')
+		second = data.find('"canonicaltitle":')
+
+		
+		data = data[:first] + data[second:]
+
+		# Remove ufeff since it causes JSON errors
+		if data.startswith(u'\ufeff'):
+			data = data[1:]
+                info = json.loads(data)
+                if not info:
+                    info = {}
+                if self.handle_api_result(info, kwargs=predata):
+                    return info.get('upload', {})
+            except requests.exceptions.HTTPError as e:
+                if e.args[0] == 503 and e.args[1].getheader('X-Database-Lag'):
+                    self.wait(wait_token, int(e.args[1].getheader('Retry-After')))
+                elif e.args[0] < 500 or e.args[0] > 599:
+                    raise
+                else:
+                    self.wait(wait_token)
+            except requests.exceptions.ConnectionError:
+                self.wait(wait_token)
+
+    def parse(self, text=None, title=None, page=None):
+        kwargs = {}
+        if text is not None:
+            kwargs['text'] = text
+        if title is not None:
+            kwargs['title'] = title
+        if page is not None:
+            kwargs['page'] = page
+        result = self.api('parse', **kwargs)
+        return result['parse']
+
+    # def block(self): TODO?
+    # def unblock: TODO?
+    # def patrol: TODO?
+    # def import: TODO?
+
+    # Lists
+    def allpages(self, start=None, prefix=None, namespace='0', filterredir='all',
+                 minsize=None, maxsize=None, prtype=None, prlevel=None,
+                 limit=None, dir='ascending', filterlanglinks='all', generator=True):
+        """Retrieve all pages on the wiki as a generator."""
+
+        pfx = listing.List.get_prefix('ap', generator)
+        kwargs = dict(listing.List.generate_kwargs(pfx, ('from', start), prefix=prefix,
+                                                   minsize=minsize, maxsize=maxsize, prtype=prtype, prlevel=prlevel,
+                                                   namespace=namespace, filterredir=filterredir, dir=dir,
+                                                   filterlanglinks=filterlanglinks))
+        return listing.List.get_list(generator)(self, 'allpages', 'ap', limit=limit, return_values='title', **kwargs)
+
+    def allimages(self, start=None, prefix=None, minsize=None, maxsize=None, limit=None,
+                  dir='ascending', sha1=None, sha1base36=None, prop='timestamp|url',
+                  generator=True):
+        """Retrieve all images on the wiki as a generator."""
+
+        pfx = listing.List.get_prefix('ai', generator)
+        kwargs = dict(listing.List.generate_kwargs(pfx, ('from', start), prefix=prefix,
+                                                   minsize=minsize, maxsize=maxsize,
+                                                   dir=dir, sha1=sha1, sha1base36=sha1base36))
+        return listing.List.get_list(generator)(self, 'allimages', 'ai', limit=limit, return_values='timestamp|url', **kwargs)
+
+    def alllinks(self, start=None, prefix=None, unique=False, prop='title',
+                 namespace='0', limit=None, generator=True):
+        """Retrieve a list of all links on the wiki as a generator."""
+
+        pfx = listing.List.get_prefix('al', generator)
+        kwargs = dict(listing.List.generate_kwargs(pfx, ('from', start), prefix=prefix,
+                                                   prop=prop, namespace=namespace))
+        if unique:
+            kwargs[pfx + 'unique'] = '1'
+        return listing.List.get_list(generator)(self, 'alllinks', 'al', limit=limit, return_values='title', **kwargs)
+
+    def allcategories(self, start=None, prefix=None, dir='ascending', limit=None, generator=True):
+        """Retrieve all categories on the wiki as a generator."""
+
+        pfx = listing.List.get_prefix('ac', generator)
+        kwargs = dict(listing.List.generate_kwargs(pfx, ('from', start), prefix=prefix, dir=dir))
+        return listing.List.get_list(generator)(self, 'allcategories', 'ac', limit=limit, **kwargs)
+
+    def allusers(self, start=None, prefix=None, group=None, prop=None, limit=None,
+                 witheditsonly=False, activeusers=False, rights=None):
+        """Retrieve all users on the wiki as a generator."""
+
+        kwargs = dict(listing.List.generate_kwargs('au', ('from', start), prefix=prefix,
+                                                   group=group, prop=prop,
+                                                   rights=rights,
+                                                   witheditsonly=witheditsonly,
+                                                   activeusers=activeusers))
+        print kwargs
+        return listing.List(self, 'allusers', 'au', limit=limit, **kwargs)
+
+    def blocks(self, start=None, end=None, dir='older', ids=None, users=None, limit=None,
+               prop='id|user|by|timestamp|expiry|reason|flags'):
+        """Retrieve blocks as a generator.
+
+        Each block is a dictionary containing:
+        - user: the username or IP address of the user
+        - id: the ID of the block
+        - timestamp: when the block was added
+        - expiry: when the block runs out (infinity for indefinite blocks)
+        - reason: the reason they are blocked
+        - allowusertalk: key is present (empty string) if the user is allowed to edit their user talk page
+        - by: the administrator who blocked the user
+        - nocreate: key is present (empty string) if the user's ability to create accounts has been disabled.
+
+        """
+
+        # TODO: Fix. Fix what?
+        kwargs = dict(listing.List.generate_kwargs('bk', start=start, end=end, dir=dir,
+                                                   users=users, prop=prop))
+        return listing.List(self, 'blocks', 'bk', limit=limit, **kwargs)
+
+    def deletedrevisions(self, start=None, end=None, dir='older', namespace=None,
+                         limit=None, prop='user|comment'):
+        # TODO: Fix
+
+        kwargs = dict(listing.List.generate_kwargs('dr', start=start, end=end, dir=dir,
+                                                   namespace=namespace, prop=prop))
+        return listing.List(self, 'deletedrevs', 'dr', limit=limit, **kwargs)
+
+    def exturlusage(self, query, prop=None, protocol='http', namespace=None, limit=None):
+        """Retrieves list of pages that link to a particular domain or URL as a generator.
+
+        This API call mirrors the Special:LinkSearch function on-wiki.
+
+        Query can be a domain like 'bbc.co.uk'. Wildcards can be used, e.g. '*.bbc.co.uk'.
+        Alternatively, a query can contain a full domain name and some or all of a URL:
+        e.g. '*.wikipedia.org/wiki/*'
+
+        See <https://meta.wikimedia.org/wiki/Help:Linksearch> for details.
+
+        The generator returns dictionaries containing three keys:
+        - url: the URL linked to.
+        - ns: namespace of the wiki page
+        - pageid: the ID of the wiki page
+        - title: the page title.
+
+        """
+
+        kwargs = dict(listing.List.generate_kwargs('eu', query=query, prop=prop,
+                                                   protocol=protocol, namespace=namespace))
+        return listing.List(self, 'exturlusage', 'eu', limit=limit, **kwargs)
+
+    def logevents(self, type=None, prop=None, start=None, end=None,
+                  dir='older', user=None, title=None, limit=None, action=None):
+
+        kwargs = dict(listing.List.generate_kwargs('le', prop=prop, type=type, start=start,
+                                                   end=end, dir=dir, user=user, title=title, action=action))
+        return listing.List(self, 'logevents', 'le', limit=limit, **kwargs)
+
+    # def protectedtitles requires 1.15
+    def random(self, namespace, limit=20):
+        """Retrieves a generator of random page from a particular namespace.
+
+        limit specifies the number of random articles retrieved.
+        namespace is a namespace identifier integer.
+
+        Generator contains dictionary with namespace, page ID and title.
+
+        """
+
+        kwargs = dict(listing.List.generate_kwargs('rn', namespace=namespace))
+        return listing.List(self, 'random', 'rn', limit=limit, **kwargs)
+
+    def recentchanges(self, start=None, end=None, dir='older', namespace=None,
+                      prop=None, show=None, limit=None, type=None, toponly=None):
+
+        kwargs = dict(listing.List.generate_kwargs('rc', start=start, end=end, dir=dir,
+                                                   namespace=namespace, prop=prop, show=show, type=type,
+                                                   toponly='1' if toponly else None))
+        return listing.List(self, 'recentchanges', 'rc', limit=limit, **kwargs)
+
+    def search(self, search, namespace='0', what='title', redirects=False, limit=None):
+
+        kwargs = dict(listing.List.generate_kwargs('sr', search=search, namespace=namespace, what=what))
+        if redirects:
+            kwargs['srredirects'] = '1'
+        return listing.List(self, 'search', 'sr', limit=limit, **kwargs)
+
+    def usercontributions(self, user, start=None, end=None, dir='older', namespace=None,
+                          prop=None, show=None, limit=None):
+
+        kwargs = dict(listing.List.generate_kwargs('uc', user=user, start=start, end=end,
+                                                   dir=dir, namespace=namespace, prop=prop, show=show))
+        return listing.List(self, 'usercontribs', 'uc', limit=limit, **kwargs)
+
+    def users(self, users, prop='blockinfo|groups|editcount'):
+
+        return listing.List(self, 'users', 'us', ususers='|'.join(users), usprop=prop)
+
+    def watchlist(self, allrev=False, start=None, end=None, namespace=None, dir='older',
+                  prop=None, show=None, limit=None):
+
+        kwargs = dict(listing.List.generate_kwargs('wl', start=start, end=end,
+                                                   namespace=namespace, dir=dir, prop=prop, show=show))
+        if allrev:
+            kwargs['wlallrev'] = '1'
+        return listing.List(self, 'watchlist', 'wl', limit=limit, **kwargs)
+
+    def expandtemplates(self, text, title=None, generatexml=False):
+        """Takes wikitext (text) and expands templates."""
+
+        kwargs = {}
+        if title is None:
+            kwargs['title'] = title
+        if generatexml:
+            kwargs['generatexml'] = '1'
+
+        result = self.api('expandtemplates', text=text, **kwargs)
+
+        if generatexml:
+            return result['expandtemplates']['*'], result['parsetree']['*']
+        else:
+            return result['expandtemplates']['*']
+
+    def ask(self, query, title=None):
+        """Ask a query against Semantic MediaWiki."""
+        kwargs = {}
+        if title is None:
+            kwargs['title'] = title
+        result = self.raw_api('ask', query=query, **kwargs)
+        return result['query']['results']
+
diff --git a/errors.py b/errors.py
index 0fbfed8..6540c2d 100644
--- a/errors.py
+++ b/errors.py
@@ -56,16 +56,3 @@ class NoSpecifiedEmail(EmailError):
 
 class NoWriteApi(MwClientError):
     pass
-
-
-class InvalidResponse(MwClientError):
-
-    def __init__(self, response_text=None):
-        self.message = 'Did not get a valid JSON response from the server. Check that ' + \
-                       'you used the correct hostname. If you did, the server might ' + \
-                       'be wrongly configured or experiencing temporary problems.'
-        self.response_text = response_text
-        MwClientError.__init__(self, self.message, response_text)
-
-    def __str__(self):
-        return self.message
diff --git a/errors.pyc b/errors.pyc
deleted file mode 100644
index 5dfec103a6b550f8fbf8144b0c29a8711aebe791..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 4225
zcmd5<ZExE)5I)(C<GlAZX|{IdJ`C`H)^55D#el9`lcqq1#mgA9Mf1f_MA~L8i3UkG
zG0<<>uiM|*AJ`pb$wGkwE07e9LF#n893LHzyoc3)*On)T|GbJ|`d7v0Z`kZ#0e}FI
z0KEW20Dl8q0K7fHmkP+hYpaE}0-}~{7Yc0^L_OCo7TOw!My_2dv<o1XbL~o@t%Fzv
zS@*N871~7*>$&Ylp>2S;1`=JPIpVoq3@m}TK?C$5Hw*1Dh+Dan+l6)o#AdGDDzvL0
z?tonN9<~eZ8i=oQ+pi1lI*7Zu_Fkdg0PzhRH}7L;-5Pd>XM3@dsoOV3n<DxcbJ(Tm
zH?YIdW3>5k6J=;tuydsDcGEDC-L6~qFNqf87+*6hRDqZ50ZQ$GPGmcL^!UjSk9Kxq
z9ffhbl|5p0+8#~ZK&OvePuf;F`EV3Q!>})HJ2{Iywzed2wl$h?@=M?>!KerBHa-re
zP~jUjRIjD6N~fRoDV)4<@^-brDW4ax<-o6@{QT(Pg|gvkEX7=6t|7*y66Q^m55sen
zj1w-MQPS?8M^XwY{%_)Zsc2KADZBG%Q@&!fKN02YIGQCn9yEBqoKz^=DKR1n0X1^C
zhs{2~?n3|{F#l1gcp(5+fp=AsX$X~7xTryZ-ZD3xCi!sGMOsKNsI;ejI!`x~N|nRi
zQy5wq_xK|I2Pg2Zj@|GqG<`eE(@Wl4wA44TS(*!iCHyrhZD)(d$z(Ramo6Cu%}wi(
ztz5-X&K;z7-0P``&Z#455@l(d&s)x|BGT;wdEi!1er2WE#e;4*e_MpM$Gs9<TH1Y~
zKCckWQsZi~VjaPKTLOCn<s+k=jGPolSS&uVvm0oa?d)>-`ckMjaQ5#?sHsrCRI%JY
zSJv5i%U`NU-+zSm58YSuSx@PVc=!?8{UlWJTxJ60>rM$R#k!-9M>0}9h1H*c&s#oF
zDfp>`nX<Q|-x#E5&qr$B(B49HKbO$b-aAO&hp`e|+L2DJEFcrx+a+5%|E7f>i8|K)
z08a3(;4c{`H6j63w1~)_8r9}KZ1zX&&<ZagTcQeEQ!<dTf-)HZc;_j>MRiIB$V10I
z!~TU5EY*(nrDGxUIN9&Ve|DIeqGdg!6XphzVGVgNO^fXfWHdxg=$L(qE+%@+##Rb%
z6lr7dG-Ly99r5xOJLoa85K25KxnYUw56}U{>Qu5bqtkvoVUbRIsy{a9O&cc9M-u5>
z8mY9;oJ>aAgl57<Mk7~EY%60aL{1WEEgrxADv=}aI(hCqwaNGbg^pA9@Gb0Sh2oN#
z0~N4evH3d-R2G9}Brp-NxV-tbBh<KHxG*_4qhU@w!&5$w^r}EQn!Ve#&UCvkQS>Ya
zf=-k8<*Y1ug4ofi^a12|2phIicgeA%Yt%2;EG1~Yvbxx5(h=o|)9`WXRFYNLY*lGf
zaI)kcHc>Y2Es0Zbs@0sfA14=_4r)&4AEyI_(>~=i-Iacj=hRQLE9o;@Uwaq3&D!+W
L$e!EzJ3jvd(Y<m6

diff --git a/ex.pyc b/ex.pyc
deleted file mode 100644
index 8700fca265605ffd6d78b5c7731449e761a4dc80..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 3648
zcmcgv-EJFI5T3LCi&ML$r7bl?Eo}q1h{kETs8p37(Et~PfHo=>6=B(UH_qB?ue0Z*
zNu=f~JO_`#L+~2B0bFuXzHioX+)4-`C0IV=bLRZbnVD~9T>7&)zyI}bkGnGYl<@m0
znzbMizD81!r_;WXr$!=Aeg@N%sHB~eL}iJ~vWck*Ifo+OKdneql~|--)rs14q9)Ot
z#B<86Pq}s8wbq`;y~zuFR=Wn>GFk=g5t_XNl8795vbQMDMOM}q<e((aJ?V=$BhS${
za_GsS5wqQtCzx4l^O)7P2kNRIJL4#Hu{)1$kjG&ZbhFWB(hD||G;Z@c*8rJeT2}*O
zoX6M~Ix48U*>h)JUev}=l-SSF>uhDixDzhlz4zhrojYmP4b#q2@slPSo$<cg%0_pW
z?saV9;@jh}I|zHR?F@IjX%dfIC*E7a8s0G@BK2UYA2C(aG<9>{bonguDb@y>{RJcz
zY6nVyrl5itIswPXV`>W8!2x^s$mo|iSXsX%KX}ySL76)2muU)Yx67(h7}k^T%=WV2
z`(*FF#1(G)x6Q+sHV<WcC{H4RK`8So%mo9qX%R=QXJfpZiteS^MwnX1S9R0O#;%SY
z)RdzQt)l|03v*|86St)%RmIvicc}4ZP3o7(<&;|3@$z6${5(4itNDCb6U|-#5z~OF
z=Dn6VXD*lpP&Wte8s73%VqKR@_~E9{(CkeR*pDa^VuL6%+5yT6+?B;&Yx7x(5boro
z9->*^3xvS>fkO7k`?*M!K!39e3Dvrd)6LURf<7_`l2PJ<V1bfRL@E50U5c*~zmE<)
z5fTH#gPP>mCJ(?6{0Ad_O)+TAKF5C@JJpx`i|8pZ2l4)?yoNvwf?n+Cf<bT%Lrc#U
z*z+|rH3PLgHAC^DzGCl4ZoXXQRxie3`Li(HnHWT$aVp}|<6sP27X*vwPmECjrkEUs
z!#D_3tRNU>(N2n?e~I$GLDB*_mQ8yn7wCK<<xMnIYSpWk>J@hu<A)lWcMy6Bm@YW_
znSzBu{1vbO8k|;}Fs^XPH)!?+h*O^eo)CQw86gdk0)%Ot98@L$LOl^-5~&0(so-lN
zY+^;Lg^+0AkI~T_He?}lU$GQJ#8BX>Ut!V%6WMTbN<~`8hLb@RgW6=!M>f=ih_n^e
z88REu{LI|EL}!@NqQ(rfAyKo)b5(;K`CmFWH(3GsT9cc~(!yR9nvs_}T`e4tx}nh(
zsXI2#r-N~5?QWJw8X&eZ>$Ect5o}A?6z@69%}e90u?FlYQ=B`-o;-H>e&CW}ob9;e
zDma?NhT$G^t;>_xYHn{cr29mWnqGr=k#T+SiacFpLcN>DS6@^C07DIBY1T_dnz0o*
zKEb6Y4R*u4XZ2x_tysomPugpV4u&s#g{PY<Uc=n*u6hgRhN+oL=CW5saL_>Q)4Bb(
zNVw_rfV40<T@haOUIEd!S(g515Y6F82G}pr>`%bfKY<9wLFE8g!S{j+P0=f2H_%ig
ze`S49>kKV5h$$ljIPZPdDDYww89#cmeP0Wgvh4kF<jzJ~E9<|@0l)-o&GD!MV5us7
z;02`!P>CN7syZN=D?)Jos#w+jK>@gVI%FUC0ccU60w2UEdJ}-+oF?m5V3MFKAcbih
zUMrAUteAym!I@%GYAO*@*&~J*Ahp#$t9KxV@G8J_0!oY~D-eXXcP91GF-m<R$Y;9o
z-zK?Eas%WTfrR21cJ*&^ZV^Ob=fA@q>*)45PE4`pzl)(_BagR{dR$T7uEo|S*~nkw
zEYFORuJf7qbkxnp`^V4>$0*h!|2@q5^kx4R38B!Yx6Htip?ILB-m~Ij9?crWXUG2l
z<QNPmm{5qaPk0rT1!$Uc-ZgXGyQtMz)4PItYysfBU@oJSzV<(Z^fpBLh{7>qRXzR7
zQz)|oMqw%{PJ>yt(T`yXX2?R<gt*!yMg8dWtYZyo@8r~|Zt|e020o@lmVb>JrctWT
L)ti^kwl4h*aFolB

diff --git a/image.pyc b/image.pyc
deleted file mode 100644
index 24d813f1a28fc7632623cb69c411751ec70b517a..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 3483
zcmcImU2hvj6rHghrwM6GDTJ1Sv@a!&Xq~2@wp1nJBSKUHQ*HPVkzl*o9mkWbcg@bY
zPSEBleMREm@E`a)`~W!TuI&_Fc%ZSovv=p?-aF@>duN(|UR*x@>W^;|HT^a5{uqyY
zfF{LXt4yg~J(C+EH<Z!pps5a8s*j<jdal%|Qa|i2aKTQeg~j$S{Ca)?;^SewZ{{Z2
z==l_n`woq%l`m5NbFFrpQ~+(eEtR4ZhM;m$nYLJ2P`l{Fza^6|h`b>3l1kgMa9M>r
zoeNN%&<j3Gcs|49U_*JO4&Zx(?pI1xT2&2IiCK%SKut^CJ8fx=L2T~;=J9W<Q_NB-
zYO|g8x0F@fKZfAbbq>oub~?*2)bp>RHAlXTqfuFmOzEw0p1Ze}9qvQAV~6OBhofrj
zOj#wxaA<O0jmxZZ_7_vRLA+TFjgQmV$5mV=1N+S6F?zTwOJHr@FZ|`%S7}Ctv%V;g
zu~W=o(`le_FUxXAzkHR9muEAaB$)*Qo`D--cOpEYz~Lyex%E*bw1SMCld%{Lxgg|+
zuuqmbll5!C`dX17$C+H(!COh=zJRnbD28SuzH|5f`*$`svm%MJjc)zQ?B2%c*bj>Q
zZukBM;5D~LadHT++{Vn~4GBhfbR04=i+CJ8R{Dm%q_63OsPSPKgpF@Qn6nY&0rA0i
zBoi2T+SEH8rcO_`<QYI~Ly6=6qD_Ygh4jJG#mqWy^L@VpnIJ!@iFzzC4%vH7Ac;jm
zYycO)){C&^7#XGC&=S-*%Mv<D6bY$-_8WvbXh>mzRxL0CPudEhJ{ww46>5eg?ST{z
zWIBLFvY+basa7Y8%=$87dRItWBz9Y^KFVKIk15a%3rP98)<DMvRiQSaPC)mf`nB1Z
zrMtvvEX?%QXLW{>a1LBC{uOxMx0yF(X;NEya$(c4QrvXXV-oNADX5GcDNhDuc4)mP
zJf-pDGLN3c+1R)aA(23aS0D+^zXX(`0!vYIOy3?!e`=wc6=L7yri{Ib4kvNB@4`!5
zNqo70TnK4Ls;2}$d=sDHwb`tho8b-i(1EGKqLjKeHOZjW2F{5*;ajl4T?>4waZTUR
zZGA;23<012&M~k-a*T}YdE$_cN106k4uXV|Of_j=k|ga*49-$V5D#C&45_R&RK(=G
z_WLe$U&rI<m8$niZqR#4iz5hRsZ^2cC!nUV{cuT@KgocccR07ee-IbMI@S85sg6Ek
z7Sss>qHq6rRh?iG4oGkxWk@Ui^S1gvU;Vcdj36a;kWqD=a=(Mm%fa-wT}<+<h||Ci
zOh7!l!Q+1LGzG3UkG(DOr-60BKF_jS^GU(PW?8Ujf=LO+n|!Vg>4N0QjssuFWamp0
z54*wFP+v~0GiNH2BF9QUSH;?5(!l1y&<s&#<~rj%4eEr#aA#uuK$Mi$9R@`|D93q@
z!Wa}|&(C^s&@aj$L*~?*a_imYxxUcUXLky9lDrSk#)!(+))t(C72E{!4l!YAxD~8T
z_SV*e*aiLc;anLPbh}-?g8EoVr-*j?>H3-CPmsj_T=fFPfmjKOy#s)^{xH}+LtkPt
zw<gsVHx9|+8e2<h_39eK6GO^KugHxQ2&pkZI)`G!GGu9!8Q+v+Q&)DBxo8>-sbUPN
zk!+gw%IPMVBbD(5zr%H^qty}~ljg}_oFAT3Zb|u@q01xL@zhh7F6tGW+^hQaMlw6O
z>5^pII}mvANW$SZiHt%%@Ux-%4Yj%>rK0CprXD@!9c>zgVC|+`6BgZcTaH^B`~K|*
zb!Cxa%*ti*q)2O|&;J}|^^YRl8p|lU3wc^%dL0RBJxZqH&c(wiiiSlx&hQz&hflfd
zgjXR+pgxZ?XTsYY;NC;lt?&aj_t2b0P^6c8>4JVmKpkOhH&)t9ttEYVaizJk+99ZN
t8=u|Py3>14eG%fBHy`1hGvw7M<laL(=jyl6?@^8E7KtWzpcTE+{2RS&F3kV{

diff --git a/listing.py b/listing.py
index ce71b9a..df7ca3f 100644
--- a/listing.py
+++ b/listing.py
@@ -1,9 +1,6 @@
-import six
-import six.moves
+import client
+import page
 from six import text_type
-from mwclient.util import parse_timestamp
-import mwclient.page
-import mwclient.image
 
 
 class List(object):
@@ -21,11 +18,13 @@ class List(object):
         if limit is None:
             limit = site.api_limit
         self.args[self.prefix + 'limit'] = text_type(limit)
+        if 'continue' not in self.args:
+            self.args['continue'] = ''
 
         self.count = 0
         self.max_items = max_items
 
-        self._iter = iter(six.moves.range(0))
+        self._iter = iter(xrange(0))
 
         self.last = False
         self.result_member = list_name
@@ -34,15 +33,15 @@ class List(object):
     def __iter__(self):
         return self
 
-    def __next__(self, full=False):
+    def next(self, full=False):
         if self.max_items is not None:
             if self.count >= self.max_items:
                 raise StopIteration
         try:
-            item = six.next(self._iter)
+            item = self._iter.next()
             self.count += 1
             if 'timestamp' in item:
-                item['timestamp'] = parse_timestamp(item['timestamp'])
+                item['timestamp'] = client.parse_timestamp(item['timestamp'])
             if full:
                 return item
 
@@ -59,12 +58,8 @@ class List(object):
             self.load_chunk()
             return List.next(self, full=full)
 
-    def next(self, full=False):
-        """ For Python 2.x support """
-        return self.__next__(full)
-
     def load_chunk(self):
-        data = self.site.api('query', (self.generator, self.list_name), *[(text_type(k), v) for k, v in six.iteritems(self.args)])
+        data = self.site.api('query', (self.generator, self.list_name), *[(text_type(k), v) for k, v in self.args.iteritems()])
         if not data:
             # Non existent page
             raise StopIteration
@@ -83,11 +78,11 @@ class List(object):
 
     def set_iter(self, data):
         if self.result_member not in data['query']:
-            self._iter = iter(six.moves.range(0))
+            self._iter = iter(xrange(0))
         elif type(data['query'][self.result_member]) is list:
             self._iter = iter(data['query'][self.result_member])
         else:
-            self._iter = six.itervalues(data['query'][self.result_member])
+            self._iter = data['query'][self.result_member].itervalues()
 
     def __repr__(self):
         return "<List object '%s' for %s>" % (self.list_name, self.site)
@@ -95,7 +90,7 @@ class List(object):
     @staticmethod
     def generate_kwargs(_prefix, *args, **kwargs):
         kwargs.update(args)
-        for key, value in six.iteritems(kwargs):
+        for key, value in kwargs.iteritems():
             if value is not None and value is not False:
                 yield _prefix + key, value
 
@@ -114,15 +109,6 @@ class List(object):
             return List
 
 
-class NestedList(List):
-    def __init__(self, nested_param, *args, **kwargs):
-        List.__init__(self, *args, **kwargs)
-        self.nested_param = nested_param
-
-    def set_iter(self, data):
-        self._iter = iter(data['query'][self.result_member][self.nested_param])
-
-
 class GeneratorList(List):
 
     def __init__(self, site, list_name, prefix, *args, **kwargs):
@@ -137,15 +123,15 @@ class GeneratorList(List):
 
         self.result_member = 'pages'
 
-        self.page_class = mwclient.page.Page
+        self.page_class = page.Page
 
     def next(self):
         info = List.next(self, full=True)
         if info['ns'] == 14:
             return Category(self.site, u'', info)
         if info['ns'] == 6:
-            return mwclient.image.Image(self.site, u'', info)
-        return mwclient.page.Page(self.site, u'', info)
+            return page.Image(self.site, u'', info)
+        return page.Page(self.site, u'', info)
 
     def load_chunk(self):
         # Put this here so that the constructor does not fail
@@ -154,10 +140,10 @@ class GeneratorList(List):
         return List.load_chunk(self)
 
 
-class Category(mwclient.page.Page, GeneratorList):
+class Category(page.Page, GeneratorList):
 
     def __init__(self, site, name, info=None, namespace=None):
-        mwclient.page.Page.__init__(self, site, name, info)
+        page.Page.__init__(self, site, name, info)
         kwargs = {}
         kwargs['gcmtitle'] = self.name
         if namespace:
@@ -182,12 +168,12 @@ class PageList(GeneratorList):
 
         kwargs = {}
         if prefix:
-            kwargs['gapprefix'] = prefix
+            kwargs['apprefix'] = prefix
         if start:
-            kwargs['gapfrom'] = start
+            kwargs['apfrom'] = start
 
         GeneratorList.__init__(self, site, 'allpages', 'ap',
-                               gapnamespace=text_type(namespace), gapfilterredir=redirects, **kwargs)
+                               apnamespace=text_type(namespace), apfilterredir=redirects, **kwargs)
 
     def __getitem__(self, name):
         return self.get(name, None)
@@ -196,9 +182,9 @@ class PageList(GeneratorList):
         if self.namespace == 14:
             return Category(self.site, self.site.namespaces[14] + ':' + name, info)
         elif self.namespace == 6:
-            return mwclient.image.Image(self.site, self.site.namespaces[6] + ':' + name, info)
+            return page.Image(self.site, self.site.namespaces[6] + ':' + name, info)
         elif self.namespace != 0:
-            return mwclient.page.Page(self.site, self.site.namespaces[self.namespace] + ':' + name, info)
+            return page.Page(self.site, self.site.namespaces[self.namespace] + ':' + name, info)
         else:
             # Guessing page class
             if type(name) is not int:
@@ -206,11 +192,11 @@ class PageList(GeneratorList):
                 if namespace == 14:
                     return Category(self.site, name, info)
                 elif namespace == 6:
-                    return mwclient.image.Image(self.site, name, info)
-            return mwclient.page.Page(self.site, name, info)
+                    return page.Image(self.site, name, info)
+            return page.Page(self.site, name, info)
 
     def guess_namespace(self, name):
-        normal_name = mwclient.page.Page.normalize_title(name)
+        normal_name = page.Page.normalize_title(name)
         for ns in self.site.namespaces:
             if ns == 0:
                 continue
@@ -230,7 +216,7 @@ class PageProperty(List):
         self.generator = 'prop'
 
     def set_iter(self, data):
-        for page in six.itervalues(data['query']['pages']):
+        for page in data['query']['pages'].itervalues():
             if page['title'] == self.page.name:
                 self._iter = iter(page.get(self.list_name, ()))
                 return
diff --git a/listing.pyc b/listing.pyc
deleted file mode 100644
index 88d614b89855b2edcede620da0a1718729615916..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 11748
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

diff --git a/page.py b/page.py
index ea54f3a..a4f2f66 100644
--- a/page.py
+++ b/page.py
@@ -1,15 +1,16 @@
-import six
+import client
+import errors
+import listing
+
+from six.moves import urllib
 from six import text_type
 import time
 import warnings
-from mwclient.util import parse_timestamp
-import mwclient.listing
-import mwclient.errors
 
 
 class Page(object):
 
-    def __init__(self, site, name, info=None, extra_properties=None):
+    def __init__(self, site, name, info=None, extra_properties={}):
         if type(name) is type(self):
             return self.__dict__.update(name.__dict__)
         self.site = site
@@ -18,9 +19,9 @@ class Page(object):
 
         if not info:
             if extra_properties:
-                prop = 'info|' + '|'.join(six.iterkeys(extra_properties))
+                prop = 'info|' + '|'.join(extra_properties.iterkeys())
                 extra_props = []
-                [extra_props.extend(extra_prop) for extra_prop in six.itervalues(extra_properties)]
+                [extra_props.extend(extra_prop) for extra_prop in extra_properties.itervalues()]
             else:
                 prop = 'info'
                 extra_props = ()
@@ -31,7 +32,7 @@ class Page(object):
             else:
                 info = self.site.api('query', prop=prop, titles=name,
                                      inprop='protection', *extra_props)
-            info = six.next(six.itervalues(info['query']['pages']))
+            info = info['query']['pages'].itervalues().next()
         self._info = info
 
         self.namespace = info.get('ns', 0)
@@ -41,16 +42,12 @@ class Page(object):
         else:
             self.page_title = self.name
 
-        self.touched = parse_timestamp(info.get('touched'))
+        self.touched = client.parse_timestamp(info.get('touched', '0000-00-00T00:00:00Z'))
         self.revision = info.get('lastrevid', 0)
         self.exists = 'missing' not in info
         self.length = info.get('length')
         self.protection = dict([(i['type'], (i['level'], i['expiry'])) for i in info.get('protection', ()) if i])
         self.redirect = 'redirect' in info
-        self.pageid = info.get('pageid', None)
-        self.contentmodel = info.get('contentmodel', None)
-        self.pagelanguage = info.get('pagelanguage', None)
-        self.restrictiontypes = info.get('restrictiontypes', None)
 
         self.last_rev_time = None
         self.edit_time = None
@@ -108,14 +105,14 @@ class Page(object):
 
     def get_expanded(self):
         """Deprecated. Use page.text(expandtemplates=True) instead"""
-        warnings.warn("page.get_expanded() was deprecated in mwclient 0.7.0 and will be removed in 0.8.0, use page.text(expandtemplates=True) instead.",
+        warnings.warn("page.get_expanded() was deprecated in mwclient 0.7.0, use page.text(expandtemplates=True) instead.",
                       category=DeprecationWarning, stacklevel=2)
 
         return self.text(expandtemplates=True)
 
     def edit(self, *args, **kwargs):
         """Deprecated. Use page.text() instead"""
-        warnings.warn("page.edit() was deprecated in mwclient 0.7.0 and will be removed in 0.8.0, please use page.text() instead.",
+        warnings.warn("page.edit() was deprecated in mwclient 0.7.0, please use page.text() instead.",
                       category=DeprecationWarning, stacklevel=2)
         return self.text(*args, **kwargs)
 
@@ -130,7 +127,7 @@ class Page(object):
         """
 
         if not self.can('read'):
-            raise mwclient.errors.InsufficientPermission(self)
+            raise errors.InsufficientPermission(self)
         if not self.exists:
             return u''
         if section is not None:
@@ -156,25 +153,19 @@ class Page(object):
         """
         if not self.site.logged_in and self.site.force_login:
             # Should we really check for this?
-            raise mwclient.errors.LoginError(self.site, 'By default, mwclient protects you from ' +
-                                             'accidentally editing without being logged in. If you ' +
-                                             'actually want to edit without logging in, you can set ' +
-                                             'force_login on the Site object to False.')
+            raise errors.LoginError(self.site, 'By default, mwclient protects you from accidentally ' +
+                                    'editing without being logged in. If you actually want to edit without '
+                                    'logging in, you can set force_login on the Site object to False.')
         if self.site.blocked:
-            raise mwclient.errors.UserBlocked(self.site.blocked)
+            raise errors.UserBlocked(self.site.blocked)
         if not self.can('edit'):
-            raise mwclient.errors.ProtectedPageError(self)
-
-        if self.section is not None and section is None:
-            warnings.warn('From mwclient version 0.8.0, the `save()` method will no longer ' +
-                          'implicitly use the `section` parameter from the last `text()` or ' +
-                          '`edit()` call. Please pass the `section` parameter explicitly to ' +
-                          'the save() method to save only a single section.',
-                          category=DeprecationWarning, stacklevel=2)
+            raise errors.ProtectedPageError(self)
+
+        if not section:
             section = self.section
 
         if not self.site.writeapi:
-            raise mwclient.errors.NoWriteApi(self)
+            raise errors.NoWriteApi(self)
 
         data = {}
         if minor:
@@ -197,32 +188,32 @@ class Page(object):
                                    summary=summary, token=self.get_token('edit'),
                                    **data)
             if result['edit'].get('result').lower() == 'failure':
-                raise mwclient.errors.EditError(self, result['edit'])
+                raise errors.EditError(self, result['edit'])
             return result
         try:
             result = do_edit()
-        except mwclient.errors.APIError as e:
+        except errors.APIError as e:
             if e.code == 'badtoken':
                 # Retry, but only once to avoid an infinite loop
                 self.get_token('edit', force=True)
                 try:
                     result = do_edit()
-                except mwclient.errors.APIError as e:
+                except errors.APIError as e:
                     self.handle_edit_error(e, summary)
             else:
                 self.handle_edit_error(e, summary)
 
         # 'newtimestamp' is not included if no change was made
         if 'newtimestamp' in result['edit'].keys():
-            self.last_rev_time = parse_timestamp(result['edit'].get('newtimestamp'))
+            self.last_rev_time = client.parse_timestamp(result['edit'].get('newtimestamp'))
         return result['edit']
 
     def handle_edit_error(self, e, summary):
         if e.code == 'editconflict':
-            raise mwclient.errors.EditError(self, summary, e.info)
+            raise errors.EditError(self, summary, e.info)
         elif e.code in ('protectedtitle', 'cantcreate', 'cantcreate-anon', 'noimageredirect-anon',
                         'noimageredirect', 'noedit-anon', 'noedit'):
-            raise mwclient.errors.ProtectedPageError(self, e.code, e.info)
+            raise errors.ProtectedPageError(self, e.code, e.info)
         else:
             raise
 
@@ -237,10 +228,10 @@ class Page(object):
 
         """
         if not self.can('move'):
-            raise mwclient.errors.InsufficientPermission(self)
+            raise errors.InsufficientPermission(self)
 
         if not self.site.writeapi:
-            raise mwclient.errors.NoWriteApi(self)
+            raise errors.NoWriteApi(self)
 
         data = {}
         if move_talk:
@@ -259,10 +250,10 @@ class Page(object):
 
         """
         if not self.can('delete'):
-            raise mwclient.errors.InsufficientPermission(self)
+            raise errors.InsufficientPermission(self)
 
         if not self.site.writeapi:
-            raise mwclient.errors.NoWriteApi(self)
+            raise errors.NoWriteApi(self)
 
         data = {}
         if watch:
@@ -287,61 +278,63 @@ class Page(object):
 
     # Properties
     def backlinks(self, namespace=None, filterredir='all', redirect=False, limit=None, generator=True):
-        prefix = mwclient.listing.List.get_prefix('bl', generator)
-        kwargs = dict(mwclient.listing.List.generate_kwargs(prefix, namespace=namespace, filterredir=filterredir))
+        prefix = listing.List.get_prefix('bl', generator)
+        kwargs = dict(listing.List.generate_kwargs(prefix,
+                                                   namespace=namespace, filterredir=filterredir))
         if redirect:
             kwargs['%sredirect' % prefix] = '1'
         kwargs[prefix + 'title'] = self.name
 
-        return mwclient.listing.List.get_list(generator)(self.site, 'backlinks', 'bl', limit=limit, return_values='title', **kwargs)
+        return listing.List.get_list(generator)(self.site, 'backlinks', 'bl', limit=limit, return_values='title', **kwargs)
 
     def categories(self, generator=True):
         if generator:
-            return mwclient.listing.PagePropertyGenerator(self, 'categories', 'cl')
+            return listing.PagePropertyGenerator(self, 'categories', 'cl')
         else:
             # TODO: return sortkey if wanted
-            return mwclient.listing.PageProperty(self, 'categories', 'cl', return_values='title')
+            return listing.PageProperty(self, 'categories', 'cl', return_values='title')
 
     def embeddedin(self, namespace=None, filterredir='all', redirect=False, limit=None, generator=True):
-        prefix = mwclient.listing.List.get_prefix('ei', generator)
-        kwargs = dict(mwclient.listing.List.generate_kwargs(prefix, namespace=namespace, filterredir=filterredir))
+        prefix = listing.List.get_prefix('ei', generator)
+        kwargs = dict(listing.List.generate_kwargs(prefix,
+                                                   namespace=namespace, filterredir=filterredir))
         if redirect:
             kwargs['%sredirect' % prefix] = '1'
         kwargs[prefix + 'title'] = self.name
 
-        return mwclient.listing.List.get_list(generator)(self.site, 'embeddedin', 'ei', limit=limit, return_values='title', **kwargs)
+        return listing.List.get_list(generator)(self.site, 'embeddedin', 'ei', limit=limit, return_values='title', **kwargs)
 
     def extlinks(self):
-        return mwclient.listing.PageProperty(self, 'extlinks', 'el', return_values='*')
+        return listing.PageProperty(self, 'extlinks', 'el', return_values='*')
 
     def images(self, generator=True):
         if generator:
-            return mwclient.listing.PagePropertyGenerator(self, 'images', '')
+            return listing.PagePropertyGenerator(self, 'images', '')
         else:
-            return mwclient.listing.PageProperty(self, 'images', '', return_values='title')
+            return listing.PageProperty(self, 'images', '', return_values='title')
 
     def iwlinks(self):
-        return mwclient.listing.PageProperty(self, 'iwlinks', 'iw', return_values=('prefix', '*'))
+        return listing.PageProperty(self, 'iwlinks', 'iw', return_values=('prefix', '*'))
 
     def langlinks(self, **kwargs):
-        return mwclient.listing.PageProperty(self, 'langlinks', 'll', return_values=('lang', '*'), **kwargs)
+        return listing.PageProperty(self, 'langlinks', 'll', return_values=('lang', '*'), **kwargs)
 
     def links(self, namespace=None, generator=True, redirects=False):
-        prefix = mwclient.listing.List.get_prefix('pl', generator)
-        kwargs = dict(mwclient.listing.List.generate_kwargs(prefix, namespace=namespace))
+        prefix = listing.List.get_prefix('pl', generator)
+        kwargs = dict(listing.List.generate_kwargs(prefix, namespace=namespace))
 
         if redirects:
             kwargs['redirects'] = '1'
         if generator:
-            return mwclient.listing.PagePropertyGenerator(self, 'links', 'pl', **kwargs)
+            return listing.PagePropertyGenerator(self, 'links', 'pl', **kwargs)
         else:
-            return mwclient.listing.PageProperty(self, 'links', 'pl', return_values='title', **kwargs)
+            return listing.PageProperty(self, 'links', 'pl', return_values='title', **kwargs)
 
     def revisions(self, startid=None, endid=None, start=None, end=None,
                   dir='older', user=None, excludeuser=None, limit=50,
                   prop='ids|timestamp|flags|comment|user', expandtemplates=False, section=None):
-        kwargs = dict(mwclient.listing.List.generate_kwargs('rv', startid=startid, endid=endid, start=start,
-                                                            end=end, user=user, excludeuser=excludeuser))
+        kwargs = dict(listing.List.generate_kwargs('rv', startid=startid, endid=endid,
+                                                   start=start, end=end, user=user, excludeuser=excludeuser))
         kwargs['rvdir'] = dir
         kwargs['rvprop'] = prop
         if expandtemplates:
@@ -349,12 +342,51 @@ class Page(object):
         if section is not None:
             kwargs['rvsection'] = section
 
-        return mwclient.listing.RevisionsIterator(self, 'revisions', 'rv', limit=limit, **kwargs)
+        return listing.RevisionsIterator(self, 'revisions', 'rv', limit=limit, **kwargs)
 
     def templates(self, namespace=None, generator=True):
-        prefix = mwclient.listing.List.get_prefix('tl', generator)
-        kwargs = dict(mwclient.listing.List.generate_kwargs(prefix, namespace=namespace))
+        kwargs = dict(listing.List.generate_kwargs('tl', namespace=namespace))
         if generator:
-            return mwclient.listing.PagePropertyGenerator(self, 'templates', prefix, **kwargs)
+            return listing.PagePropertyGenerator(self, 'templates', 'tl')
         else:
-            return mwclient.listing.PageProperty(self, 'templates', prefix, return_values='title', **kwargs)
+            return listing.PageProperty(self, 'templates', 'tl', return_values='title')
+
+
+class Image(Page):
+
+    def __init__(self, site, name, info=None):
+        Page.__init__(self, site, name, info,
+                      extra_properties={'imageinfo':
+                                        (('iiprop', 'timestamp|user|comment|url|size|sha1|metadata|archivename'), )
+                                        })
+        self.imagerepository = self._info.get('imagerepository', '')
+        self.imageinfo = self._info.get('imageinfo', ({}, ))[0]
+
+    def imagehistory(self):
+        return listing.PageProperty(self, 'imageinfo', 'ii',
+                                    iiprop='timestamp|user|comment|url|size|sha1|metadata|archivename')
+
+    def imageusage(self, namespace=None, filterredir='all', redirect=False,
+                   limit=None, generator=True):
+        prefix = listing.List.get_prefix('iu', generator)
+        kwargs = dict(listing.List.generate_kwargs(prefix, title=self.name,
+                                                   namespace=namespace, filterredir=filterredir))
+        if redirect:
+            kwargs['%sredirect' % prefix] = '1'
+        return listing.List.get_list(generator)(self.site, 'imageusage', 'iu',
+                                                limit=limit, return_values='title', **kwargs)
+
+    def duplicatefiles(self, limit=None):
+        return listing.PageProperty(self, 'duplicatefiles', 'df',
+                                    dflimit=limit)
+
+    def download(self):
+        url = self.imageinfo['url']
+        if not url.startswith('http://'):
+            url = 'http://' + self.site.host + url
+        url = urllib.parse.urlparse(url)
+        # TODO: query string
+        return self.site.connection.get(url[1], url[2])
+
+    def __repr__(self):
+        return "<Image object '%s' for %s>" % (self.name.encode('utf-8'), self.site)
diff --git a/page.pyc b/page.pyc
deleted file mode 100644
index be0647b88f89b9262ea59c156a2d10efc46446d4..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 15392
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
IMpah-7mEwpU;qFB

diff --git a/sleep.pyc b/sleep.pyc
deleted file mode 100644
index 3c5f27c0de5d6613d7198feb904b975b4f54751b..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 2650
zcmcIm&2Aev5T4zY<j8SqBX!djC{O}M0UZ)4PJ#GR1Vw`W92y<g?V-A?s9j2;yg$a0
zie(_Z)Om@%QeUSJ(0((kAJoXvmd(+SJ3E{ie&0~hKacjW-~RnuO6yOA@9#03gUIk7
zP);=3>H&>{&3Z_qQ1p=Uh>8}CS`?U&7Hu*ex`F8)Wf7SNG{rkD`apC;^!unw87!LB
z&USU5_d4(GVPE?%KEqxB)jxrFt5>#I7P0ZQHSUL1YD{J_{{WB9b7L+|?Y0SoSbUA)
zP9O|ImvFH)ynjGQh&ZAw6um|9d9MXKd7HQ6@e_vQ)eP<>h;=BuHmpk11jeST9t4SS
zKSLYLtHKQQ^A~5|K0iIpt5oNMe)E;v$>8$Z&#Ur9|7_r_H_tA0dZA~=4T`HYx2E(1
z$Jz8@#;JXm>td4WR}Z1{X;8`m@ZcQZV7RX#-UsxaD1j1+f@vg*oXsYI2$r5b6?&D_
zO(Fdw%vrxqye&+%^s+C4&L;>>D&u)SXYy&>h7xyJ@Dbf-;z?pl>ytzh=N&2N;xFa2
zd2l3>{#Q`^rUDD8!$OL%i0G!ZJv>gqbI@zB+)jmk#$0hpR@XCkU)gaag}yLH_;$Q4
z1;ZYvBZW_rQWqvk{61Eaq^PoGj%nP*G?pL_pzUH4?M`tQGpKnx!G9+_Y{wjn&;#F6
z{nz~X1Y%1r<`l>Ut_iciFDBZST&@qV`wE{Qt6J&uTFvY`Q>qHQ)!tU+Q>E2-eKuoN
zO%^8g>H<t~Dy^2KSJhPcxl!e^n3x(fakd6=U%VQf&Xqv<shA3p6r)<%GOdkv#wob6
zxjY65KJHCf2RCqLGDM1@#vgA!W3klMnXIpVMR2mCsU@^^3T|F4^Gr>Q%B)Lujh>~d
zGBpyyHhXsDmT797n=bRdI7k^2Jowb#V7OC=Ez?nLraWXrdB}$HkS%%CYMK|nKC}=d
zD2tg<!i074ZZm<m6eft}?Wf|0#oc0#@y1Mc47G;pOm_)eI3Hn|nInbx3ks5NEu^EL
zh1~dvFk>0eMT_c}<fSgWf<_S1p8=JPfmCN_kEam@Ja4bPptN5c|AE)>4{zv?D^{=q
z557YSTxs$YZUeA((PdNIbpc@CTqf=YA<8i_<^|VEs{%a@cNk-N3|%_zSUHncW#*bw
zXLE*<PW@8n4Wev0YhZk3^L&eCb!Gkh|C|u?<96J+vP@?8IfTT(o~9t+H`!*_VUH^w
zAF_~>heFNCbGMXc@45JSHS=tcnaOe{O_G@<O9J~I8#Nu2+vp}eLE8Fe*>$bE1<$A0
z?*zj=hM@Lg@HqG^{4zWa4gjH}pn*N#bMYq-5>b+5Rk~@b{QfSsd+4ZK;$sZQ7g?v%
z3A=kep&`#}^q8uMId%yRg`VM@JRiyCM?v4zbyd3<OXQg=Gvj}OovCBVi|-Nulc?!B
h(!!-{-)CCQ50vJHdL=mHtLXq$KM0P(!|2Jw{{SDlM)Cjv

diff --git a/util.py b/util.py
index bcd7b60..4b639c1 100644
--- a/util.py
+++ b/util.py
@@ -1,7 +1,7 @@
-import time
+# encoding=utf-8
 
 
 def parse_timestamp(t):
-    if t is None or t == '0000-00-00T00:00:00Z':
-        return (0, 0, 0, 0, 0, 0, 0, 0, 0)
+    if t == '0000-00-00T00:00:00Z':
+        return (0, 0, 0, 0, 0, 0, 0, 0)
     return time.strptime(t, '%Y-%m-%dT%H:%M:%SZ')
diff --git a/util.pyc b/util.pyc
deleted file mode 100644
index 6330748c96d9143ef1f65deb7d79affab63c2e2d..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 539
zcmb_ZO-lnY5S{E+S&JfwhYDU7_TV<#dMFeT!Gm79hqfNvi>$lB#%4cgQcA&_{yP7T
zKR{oi;MIe}%*)FpGxI|HkAv=Z@_tv)k9k<H5c&jA!Wk)|48)^15N0#8$j7Ptgrx-o
zwb4afBlH>I#T73D(mlr+Ej?PDQrV%IVf5^|tWU2Vn(d$<)yKdD7CWCO$=G=&ktclw
z2=C*tio<dq-j2h`IGknC9@6f@U%@Fi9h9X_EgUhj5+<-i%&N7U$UX-u0TF;4=o>J;
zXez<;WH>rc1_RX;x#IorMaf6rZq1^phy4-P(ulati)H>KG_N*=lA<<zZKUes)**Ve
x`AUliJ5QUuYON%_3n12G9TwS-m|6`}d-AK}|HTC8e^E8%T8T?LP}|Y_{uiL6Z2<rP

-- 
1.9.1

